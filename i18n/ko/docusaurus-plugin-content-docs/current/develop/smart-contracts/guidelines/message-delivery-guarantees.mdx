import ConceptImage from "@site/src/components/conceptImage";

# 메시지 전달 보증

TON은 다른 블록체인과 매우 다른 복잡한 구조를 가진 비동기 블록체인입니다. 이로 인해 새로운 개발자들은 TON에서의 저수준 내용에 대한 질문을 자주 가지게 됩니다. 이 문서에서는 메시지 전달과 관련된 이러한 질문 중 하나를 살펴보겠습니다.

## 메시지란 무엇인가요?

Ethereum이나 거의 모든 다른 동기 블록체인을 살펴보면 각 거래가 여러 스마트 계약 호출을 포함할 수 있습니다. 예를 들어, DEX는 선택한 거래 페어에 유동성이 없는 경우 한 거래에서 여러 거래를 수행합니다.

비동기 시스템에서는 동일한 거래 내에서 대상 스마트 계약으로부터 응답을 받을 수 없습니다. 계약 호출은 출발지와 목적지 사이의 경로 길이에 따라 처리되기까지 몇 블록이 걸릴 수 있습니다.

무한한 샤딩 패러다임을 달성하려면 모든 것이 완전한 병렬 처리가 보장되어야 합니다. 이것은 모든 다른 스마트 계약의 독립적인 실행을 의미하며, 따라서 여러 개의 스마트 계약 상태를 한 번에 영향을 주고 변경하는 거래 대신 TON에서는 각 거래가 하나의 스마트 계약에서만 실행되며 스마트 계약은 메시지를 통해 통신합니다. 이렇게 하면 스마트 계약은 특별한 메시지를 사용하여 서로의 함수를 호출하고 나중에 다른 메시지를 통해 응답을 받는 방식으로만 상호 작용할 수 있습니다.

Ethereum에서 거래가 다른 계약의 함수 호출 집합일 때, TON에서의 거래는 초기에 트리거된 입받은 메시지와 다른 계약에 보내진 일련의 발신 메시지로 구성됩니다.

## 논리 시간이란 무엇인가요?

비동기 및 병렬 스마트 계약 호출이 있는 이러한 시스템에서 처리할 작업의 순서를 정의하는 것은 어려울 수 있습니다. 이것이 바로 TON의 각 메시지에는 _논리 시간_ 또는 _램포트 시간_ (이후 *lt*로만 표시)이 있는 이유입니다. 이것은 어떤 이벤트가 다른 이벤트를 일으킨 것인지 이해하고 검증자가 먼저 처리해야 할 것을 파악하는 데 사용됩니다.

메시지로부터 생성된 거래의 *lt*는 반드시 메시지의 *lt*보다 커야 하는 것이 엄격하게 보장됩니다. 마찬가지로, 특정 거래에서 전송된 메시지의 *lt*는 그것을 일으킨 거래의 *lt*보다 엄격하게 커야 합니다. 또한, 하나의 계정에서 전송된 메시지와 해당 계정에서 발생한 거래도 엄격하게 정렬됩니다. 이로 인해 모든 계정에 대해 항상 거래, 수신 메시지 및 발신 메시지의 순서를 알 수 있습니다.

또한, 계정 A가 계정 B로 두 개의 메시지를 보낸 경우 더 낮은 *lt*를 가진 메시지가 더 빨리 처리될 것이라는 것이 보장됩니다. 그렇지 않으면 하나의 샤드를 처리하기 전에 모든 다른 샤드의 상태를 알아야 하므로 병렬화를 깨뜨리고 효율적인 샤딩을 파괴할 것입니다.

각 블록에 대해 _lt_ 범위를 정의할 수 있으며, 이 범위는 첫 번째 거래에서 시작하여 블록의 마지막 이벤트 (_메시지 또는 거래_)의 *lt*로 끝납니다. 블록은 TON의 다른 이벤트와 동일한 방식으로 정렬되며 따라서 한 블록이 다른 블록에 의존하는 경우 더 높은 *lt*를 가집니다. 샤드 내의 자식 블록은 부모 블록보다 더 높은 *lt*를 가집니다. 마스터체인 블록의 *lt*는 나열된 샤드 블록에 의존하기 때문에 나열된 샤드 블록의 *lt*보다 더 높습니다. 각 샤드 블록은 생성 시점에서 가장 최신의 (마스터 블록의 *lt*보다 높은) 마스터 블록에 대한 정렬된 참조를 포함하며 따라서 샤드 블록의 *lt*는 참조된 마스터 블록의 *lt*보다 높습니다.

## 메시지 전달

다행히도 TON은 내부 메시지는 반드시 대상 계정에 의해 수신될 것이라는 방식으로 작동합니다. 메시지는 출발지와 목적지 사이의 어느 곳에서도 소실될 수 없습니다. 외부 메시지는 검증자의 재량에 따라 블록에 수용되지만 한 번 들어오는 메시지 대기열로 수용되면 반드시 전달됩니다.

### 전달 순서

따라서 *lt*가 메시지 전달 순서에 대한 문제를 해결하는 것처럼 보입니다. 낮은 *lt*를 가진 거래가 먼저 처리된다는 사실을 알기 때문입니다. 그러나 이것은 모든 시나리오에서 동작하지는 않습니다.

계약 *A*와 _B_ 두 개가 있다고 가정해 보겠습니다. *A*는 외부 메시지를 수신하고 이로 인해 *B*에게 두 개의 내부 메시지를 보내게 됩니다. 이 메시지를 _1_ 및 *2*라고 부르겠습니다. 이 간단한 경우에서는 *1*이 *2*보다 낮은 *lt*를 가지므로 *1*이 *B*에서 먼저 처리될 것임을 확신할 수 있습니다.

<ConceptImage src="/img/docs/msg-delivery-1.png" />

그러나 이것은 두 개의 계약만 있는 간단한 경우에 불과합니다. 더 복잡한 경우에는 시스템이 어떻게 작동할까요?

### 여러 스마트 계약

세 개의 계약 _A_, _B_ 및 *C*가 있다고 가정해 보겠습니다. 한 거래에서 *A*는 _1_ 및 *2*라는 두 개의 내부 메시지를 보냅니다. 하나는 *B*로, 다른 하나는 *C*로 전송됩니다. 이러한 메시지는 정확한 순서로 생성되었지만 (*1*이 _2_ 앞에 생성됨) *1*이 *2*보다 먼저 처리될 것을 확신할 수 없습니다. 이것은 *A*에서 *B*로 및 *A*에서 *C*로의 경로가 길이와 검증자 집합이 다를 수 있기 때문입니다. 이 계약이 다른 샤드 체인에 있는 경우, 이러한 메시지 중 하나는 대상 계약에 도달하기 위해 여러 블록이 필요할 수 있습니다.

<ConceptImage src="/img/docs/msg-delivery-2.png" />

두 계약 _B_ 및 *C*가 하나의 계약 *A*로 메시지를 보내는 역방향 경우도 마찬가지입니다. 메시지 `B -> A`가 `C -> A`보다 먼저 보내졌더라도 어떤 것이 먼저 전달될지 알 수 없습니다. `B -> A` 경로는 여러 샤드 체인 홉이 필요할 수 있습니다.

<ConceptImage src="/img/docs/msg-delivery-3.png" />

스마트 계약 상호 작용에는 많은 가능한 시나리오가 있을 수 있으며, 2개 이상의 계약을 사용하는 모든 시나리오에서 메시지 전달 순서는 임의적일 수 있습니다. 메시지는 모든 계약 *A*에서 모든 계약 *B*로 전달될 때 논리 시간의 순서대로 처리될 것임이 보장됩니다. 몇 가지 예시는 아래에 나와 있습니다.

<ConceptImage src="/img/docs/msg-delivery-4.png" />
<ConceptImage src="/img/docs/msg-delivery-5.png" />
<ConceptImage src="/img/docs/msg-delivery-6.png" />

## 결론

TON 블록체인의 비동기 구조는 메시지 전달 보증에 대한 도전 과제를 제공합니다. 논리 시간은 이벤트 및 거래 순서를 확립하는 데 도움이 되지만, 샤드 체인의 경로가 다르기 때문에 여러 스마트 계약 간의 메시지 전달 순서를 보장하지 않습니다. 그럼에도 불구하고 TON은 내부 메시지 전달을 보장하며 네트워크 신뢰성을 유지합니다. 개발자는 이러한 세부 사항에 적응하여 혁신적인 분산 애플리케이션 구축에 TON의 모든 잠재력을 활용해야 합니다.
