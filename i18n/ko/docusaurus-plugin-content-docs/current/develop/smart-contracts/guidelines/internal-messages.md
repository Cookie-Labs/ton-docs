# 내부 메시지

## 개요

스마트 계약은 서로 상호 작용하기 위해 **내부 메시지**라고 불리는 메시지를 보내며, 내부 메시지가 목적지에 도달하면 목적지 계정을 대표하는 일반 트랜잭션이 생성되고 내부 메시지는 이 계정(스마트 계약)의 코드 및 지속적인 데이터에 따라 처리됩니다.

:::info
특히, 처리 트랜잭션은 하나 이상의 외부 내부 메시지를 생성할 수 있으며, 이 중 일부는 처리 중인 내부 메시지의 출처 주소를 대상으로 할 수 있습니다. 이것은 내부 메시지에 캡슐화된 쿼리를 생성하고 다른 스마트 계약으로 전송하고 다시 내부 메시지로 응답을 보내는 간단한 "클라이언트-서버 응용 프로그램"을 만들기 위해 사용할 수 있습니다.
:::

이러한 접근 방식은 내부 메시지가 "쿼리", "응답" 또는 "단순한 자금 이체"와 같이 추가 처리가 필요한지 여부를 구별해야 함을 필요로 합니다. 또한 응답을 받으면 어떤 쿼리와 관련이 있는지 이해하기 위한 수단이 있어야 합니다.

이러한 목표를 달성하기 위해 내부 메시지 레이아웃에 대한 다음 접근 방법을 사용할 수 있습니다(TON 블록체인은 메시지 본문에 대한 제한 사항을 강요하지 않으므로 이것은 권장 사항일 뿐입니다).

### 내부 메시지 구조

메시지의 본문은 메시지 자체에 포함될 수 있거나 메시지에서 참조하는 별도의 셀에 저장될 수 있습니다. 이를 TL-B 스키마 단편에서 나타낸 대로 볼 수 있습니다.

```tlb
message$_ {X:Type} ... body:(Either X ^X) = Message X;
```

수신 스마트 계약은 적어도 메시지 본문이 메시지를 포함하는 셀에 맞는 경우 내부 메시지를 수용해야 합니다. 메시지 본문을 별도의 셀에서 ( `(Either X ^X)`의 `right` 생성자를 사용하여) 수용하는 경우 들어오는 메시지의 처리는 메시지 본문에 대한 특정 포함 옵션에 따라 달라져서는 안됩니다. 반면에 간단한 쿼리와 응답의 경우 별도의 셀에서 메시지 본문을 지원하지 않는 것도 완전히 유효합니다.

### 내부 메시지 본문

메시지 본문은 일반적으로 다음 필드로 시작합니다.

```
* A 32-bit (big-endian) unsigned integer `op`, identifying the `operation` to be performed, or the `method` of the smart contract to be invoked.
* A 64-bit (big-endian) unsigned integer `query_id`, used in all query-response internal messages to indicate that a response is related to a query (the `query_id` of a response must be equal to the `query_id` of the corresponding query). If `op` is not a query-response method (e.g., it invokes a method that is not expected to send an answer), then `query_id` may be omitted.
* The remainder of the message body is specific for each supported value of `op`.
```

### 주석이 있는 단순 메시지

`op`가 0인 경우, 메시지는 "주석이 있는 간단한 전송 메시지"입니다. 주석은 메시지 본문의 나머지 부분에 포함되며 (`query_id` 필드 없이, 다시 말해서 다섯 번째 바이트부터 시작), 바이트 `0xff`로 시작하지 않는 경우 텍스트 주석입니다. 이 주석은 유효하지 않거나 제어 문자를 필터링하고 유효한 UTF-8 문자열인지 확인한 후 지갑의 최종 사용자에게 그대로 표시될 수 있습니다.

주석이 셀에 맞지 않을만큼 충분히 긴 경우, 맞지 않는 라인의 끝은 셀의 첫 번째 참조에 넣습니다. 이 과정은 2 개 이상의 셀에 맞지 않는 주석을 설명하기 위해 재귀적으로 계속됩니다.

```
root_cell("0x00000000" - 32 bit, "string" up to 123 bytes)
         ↳1st_ref("string continuation" up to 127 bytes)
                 ↳1st_ref("string continuation" up to 127 bytes)
                         ↳....
```

동일한 형식은 NFT 및 [jetton](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#forward_payload-format) 전송의 주석에도 사용됩니다.

예를 들어, 사용자는 이 텍스트 필드에서 다른 사용자의 지갑으로의 간단한 이체의 목적을 나타낼 수 있습니다. 반면에 주석이 바이트 `0xff`로 시작하면 나머지 부분은 "바이너리 주석"으로, 필요한 경우 텍스트로 표시해서는 안 되며(필요한 경우 헥스 덤프로만 표시), 예를 들어 상점에서 결제를 위한 구매 식별자를 포함하는 것과 같이 상점 소프트웨어에 의해 자동으로 생성되고 처리될 목적으로 사용됩니다.

대부분의 스마트 계약은 간단한 전송 메시지"를 받았을 때 비트 연산을 수행하거나 수신 메시지 처리를 거부해서는 안됩니다. 이렇게 하면 `op`가 0으로 확인되면 일반적으로 내부 메시지를 처리하는 스마트 계약 함수(보통 `recv_internal()`라고 함)가 메시지 전달로 인해 추가적인 효과 없이 즉시 성공을 나타내는 0 종료 코드로 종료되어야 합니다(스마트 계약에서 사용자 정의 예외 처리기가 설치되어 있지 않은 경우 예외 `0`을 던지는 방식으로). 이렇게 하면 메시지로 전송된 값을 추가 효과 없이 수신 계정에 입금하게 됩니다.

### 암호화된 주석이 있는 메시지

`op`가 `0x2167da4b`인 경우, 메시지는 "암호화된 주석이 있는 전송 메시지"입니다. 이 메시지는 다음과 같이 직렬화됩니다.

입력:

- `pub_1` 및 `priv_1` - 발신자의 Ed25519 공개 및 개인 키, 각각 32 바이트.
- `pub_2` - 수신자의 Ed25519 공개 키, 32 바이트.
- `msg` - 암호화할 메시지, 임의의 바이트 문자열. `len(msg) <= 960`.

암호화 알고리즘은 다음과 같습니다.

1. `priv_1`과 `pub_2`를 사용하여 `shared_secret` 계산합니다.
2. `salt`를 발신자 지갑 주소의 [bas64url 표현](https://docs.ton.org/learn/overviews/addresses#user-friendly-address)으로 설정합니다 (`isBounceable=1` 및 `isTestnetOnly=0` 사용).
3. `len(prefix+msg)`가 16으로 나누어지는 길이 사이가 될 수 있는 16에서 31 길이의 바이트 문자열 `prefix`를 선택합니다. `prefix`의 첫 번째 바이트는 `len(prefix)`와 같으며, 다른 바이트는 임의로 생성됩니다. `data = prefix + msg`를 설정합니다.
4. `msg_key`를 `hmac_sha512(salt, data)`의 처음 16 바이트로 설정합니다.
5. `shared_secret`를 사용하여 `x = hmac_sha512(shared_secret, msg_key)`를 계산합니다. `key=x[0:32]` 및 `iv=x[32:48]`를 설정합니다.
6. `key`와 `iv`를 사용하여 AES-256을 CBC 모드로 사용하여 `data`를 암호화합니다.
7. 암호화된 주석을 구성합니다:
   1. `pub_1 ^ pub_2` - 32 바이트. 이로써 각 당사자는 상대방의 공개 키를 조회하지 않고도 메시지를 복호화할 수 있습니다.
   2. `msg_key` - 16 바이트.
   3. 암호화된 `data`.
8. 메시지의 본문은 4바이트 태그 `0x2167da4b`로 시작합니다. 그런 다음이 암호화된 주석이 저장됩니다.
   1. 바이트 문자열은 셀 체인 `c_1, ... ,c_k`에 저장되며 (`c_1`이 본문의 루트인 경우), 각 셀(마지막 셀 제외)은 다음을 참조합니다.
   2. `c_1`에는 35바이트까지 포함됩니다(4바이트 태그 제외), 다른 모든 셀에는 최대 127바이트까지 포함됩니다.
   3. 이 형식에는 다음 제한이 있습니다. `k <= 16`, 최대 문자열 길이는 1024입니다.

동일한 형식은 NFT 및 jetton 전송의 주석에도 사용됩니다. 발신자 주소와 수신자 주소 (jetton-wallet 주소가 아님)의 공개 키를 사용해야 합니다.

:::info
메시지 암호화 알고리즘의 예제를 확인하려면 다음을 참조하십시오.

- [encryption.js](https://github.com/toncenter/ton-wallet/blob/master/src/js/util/encryption.js)
- [SimpleEncryption.cpp](https://github.com/ton-blockchain/ton/blob/master/tonlib/tonlib/keys/SimpleEncryption.cpp)

:::

### 주석이 없는 단순 전송 메시지

"주석이 없는 간단한 전송 메시지"는 비어 있는 본문을 가지며 (`op` 필드도 없음) 이러한 메시지에 대한 위 고려사항도 적용됩니다. 이러한 메시지는 메시지 셀에 본문이 포함되어야 합니다.

### 쿼리 및 응답 메시지의 구분

"쿼리" 메시지는 `op`의 최상위 비트가 설정되지 않은 범위, 즉 `1 .. 2^31-1` 범위에 있는 것으로 예상되고, "응답" 메시지는 `op`의 최상위 비트가 설정된 범위, 즉 `2^31 .. 2^32-1` 범위에 있는 것으로 예상됩니다. 메서드가 쿼리나 응답이 아닌 경우 (해당 메시지 본문에 `query_id` 필드가 포함되지 않는 경우) 쿼리 범위 `1 .. 2^31 - 1` 내에서 `op`를 사용해야 합니다.

### 표준 응답 메시지 처리

`op`가 `0xffffffff` 및 `0xfffffffe`인 일부 "표준" 응답 메시지가 있습니다. 일반적으로 `op`가 `0xfffffff0`에서 `0xffffffff`로 설정된 값은 이러한 표준 응답을 위해 예약됩니다.

- `op` = `0xffffffff`는 "지원되지 않는 작업"을 의미합니다. 이는 원래 쿼리에서 추출된 64비트 `query_id` 및 원래 쿼리의 32비트 `op`를 따릅니다. 모든 간단한 스마트 계약은 알려지지 않은 `op`를 가진 쿼리를 받았을 때이 오류를 반환해야 합니다 (`1 .. 2^31-1` 범위 내에서 알려지지 않은 `op`가 있는 쿼리를 받은 경우).
- `op` = `0xfffffffe`는 "허용되지 않는 작업"을 의미합니다. 이는 원래 쿼리에서 추출된 64비트 `query_id` 및 원래 쿼리의 32비트 `op`를 따릅니다.

알려지지 않은 "응답" (범위 `2^31 .. 2^32-1` 내에서 `op`를 가진 응답)은 무시되어야 합니다(특히 이러한 응답에 대한 응답으로 `op`가 `0xffffffff`와 같은 응답이 생성되어서는 안 됩니다), "반송" 플래그가 설정된 예상치 못한 반송된 메시지와 마찬가지로.
